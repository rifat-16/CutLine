rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() {
      return request.auth != null;
    }

    function userRole(uid) {
      return exists(/databases/$(database)/documents/users/$(uid))
        ? get(/databases/$(database)/documents/users/$(uid)).data.role
        : null;
    }

    function isOwner(uid) {
      return userRole(uid) == 'owner';
    }

    function isBarber(uid) {
      return userRole(uid) == 'barber';
    }

    function barberOwnerId(barberUid) {
      return exists(/databases/$(database)/documents/users/$(barberUid))
        ? get(/databases/$(database)/documents/users/$(barberUid)).data.ownerId
        : null;
    }

    function salonOwner(salonId) {
      return exists(/databases/$(database)/documents/salons/$(salonId)) 
        ? get(/databases/$(database)/documents/salons/$(salonId)).data.ownerId 
        : null;
    }

    function isValidStatus(status) {
      return status in ['pending', 'called', 'served', 'cancelled'];
    }

    match /users/{userId} {
      // Users can read their own document
      // Owners can read customer user documents to display avatars
      // Barbers can read their own document
      // Customers can read barber user documents to display barber profiles/avatars
      allow read: if isAuthenticated() && (
        request.auth.uid == userId ||
        isOwner(request.auth.uid) ||
        isBarber(request.auth.uid) ||
        true  // Allow all authenticated users to read user documents for displaying profiles/avatars
      );
      allow create, update: if isAuthenticated() && request.auth.uid == userId;
      allow delete: if false;
      
      // Nested favorites collection
      match /favorites/{salonId} {
        // Users can read/write their own favorites
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    match /salons/{salonId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated()
        && isOwner(request.auth.uid)
        && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isAuthenticated() && salonId == request.auth.uid;
      
      // Nested queue collection
      match /queue/{queueId} {
        // Owner can read/write their salon's queue
        // Barber can read their owner's salon queue
        // Customers can read queue to see wait times and live queue status
        allow read: if isAuthenticated() && (
          salonId == request.auth.uid ||
          (isBarber(request.auth.uid) && barberOwnerId(request.auth.uid) == salonId) ||
          true  // Allow all authenticated users to read queue for wait time estimates and live queue
        );
        allow create, update: if isAuthenticated() && (
          salonId == request.auth.uid ||
          (isBarber(request.auth.uid) && barberOwnerId(request.auth.uid) == salonId)
        );
        allow delete: if isAuthenticated() && salonId == request.auth.uid;
      }
      
      // Nested bookings collection
      match /bookings/{bookingId} {
        // Owner, barber, and all customers can read bookings for live queue display
        // Customers need to see all bookings to view the live queue status
        // Support both userId and customerUid field names for compatibility
        allow read: if isAuthenticated() && (
          salonId == request.auth.uid ||
          resource.data.userId == request.auth.uid ||
          resource.data.customerUid == request.auth.uid ||
          (isBarber(request.auth.uid) && barberOwnerId(request.auth.uid) == salonId) ||
          true  // Allow all authenticated users to read bookings for live queue display
        );
        allow create: if isAuthenticated() && (
          salonId == request.auth.uid ||
          request.resource.data.userId == request.auth.uid ||
          request.resource.data.customerUid == request.auth.uid
        );
        allow update: if isAuthenticated() && (
          salonId == request.auth.uid ||
          resource.data.userId == request.auth.uid ||
          resource.data.customerUid == request.auth.uid ||
          (isBarber(request.auth.uid) && barberOwnerId(request.auth.uid) == salonId)
        );
        allow delete: if isAuthenticated() && salonId == request.auth.uid;
      }
      
      // Nested barbers collection (for barber availability)
      match /barbers/{barberId} {
        // Anyone authenticated can read barbers (customers need to see barbers for booking)
        allow read: if isAuthenticated();
        allow create, update: if isAuthenticated() && (
          salonId == request.auth.uid ||
          barberId == request.auth.uid
        );
        allow delete: if isAuthenticated() && salonId == request.auth.uid;
      }
    }

    match /bookings/{bookingId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        salonOwner(resource.data.salonId) == request.auth.uid
      );

      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && isValidStatus(request.resource.data.status);

      allow update: if isAuthenticated()
        && (
          resource.data.userId == request.auth.uid ||
          salonOwner(resource.data.salonId) == request.auth.uid
        )
        && isValidStatus(request.resource.data.status);

      allow delete: if false;
    }

    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if false; // Only Cloud Functions can create
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Top-level queue collection (fallback)
    match /queue/{queueId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAuthenticated() && isOwner(request.auth.uid);
    }
  }
}
